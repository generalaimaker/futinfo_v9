import Foundation

enum FootballAPIError: LocalizedError, Equatable {
    case invalidURL
    case invalidResponse
    case rateLimitExceeded
    case apiError([String])     // ÏõêÎûò Î∞∞Ïó¥ ÌòïÌÉúÎ°ú ÎêòÎèåÎ¶º
    case decodingError(Error)
    case missingAPIKey
    
    static func == (lhs: FootballAPIError, rhs: FootballAPIError) -> Bool {
        switch (lhs, rhs) {
        case (.invalidURL, .invalidURL),
             (.invalidResponse, .invalidResponse),
             (.rateLimitExceeded, .rateLimitExceeded),
             (.missingAPIKey, .missingAPIKey):
            return true
        case (.apiError(let lhsErrors), .apiError(let rhsErrors)):
            return lhsErrors == rhsErrors
        case (.decodingError, .decodingError):
            // Error ÌîÑÎ°úÌÜ†ÏΩúÏùÄ EquatableÏùÑ Ï§ÄÏàòÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú ÌÉÄÏûÖÎßå ÎπÑÍµê
            return true
        default:
            return false
        }
    }
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "ÏûòÎ™ªÎêú URLÏûÖÎãàÎã§."
        case .invalidResponse:
            return "ÏÑúÎ≤ÑÎ°úÎ∂ÄÌÑ∞ ÏûòÎ™ªÎêú ÏùëÎãµÏùÑ Î∞õÏïòÏäµÎãàÎã§."
        case .rateLimitExceeded:
            return "API ÏöîÏ≤≠ ÌïúÎèÑÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§."
        case .apiError(let messages):
            return messages.joined(separator: ", ")
        case .decodingError(let error):
            return "Îç∞Ïù¥ÌÑ∞ ÎîîÏΩîÎî© Ïò§Î•ò: \(error.localizedDescription)"
        case .missingAPIKey:
            return "API ÌÇ§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
        }
    }
}

class FootballAPIService {
    private let baseURL = "https://api-football-v1.p.rapidapi.com/v3"
    private let host = "api-football-v1.p.rapidapi.com"
    private let apiKey: String
    
    private var requestsLimit: Int = 0
    private var requestsRemaining: Int = 0
    private var rateLimitPerMinute: Int = 0
    private var rateLimitRemainingPerMinute: Int = 0
    
    static let shared = FootballAPIService()
    
    // MARK: - Leagues
    
    func getCurrentLeagues() async throws -> [LeagueDetails] {
        var allLeagues: [LeagueDetails] = []
        let currentSeason = 2024 // 2024-25 ÏãúÏ¶å
        
        print("\nüéØ Starting to fetch league details...")
        
        for leagueId in SupportedLeagues.allLeagues {
            do {
                print("\nüèÜ Fetching details for league \(leagueId) (\(SupportedLeagues.getName(leagueId)))")
                let league = try await getLeagueDetails(leagueId: leagueId, season: currentSeason)
                allLeagues.append(league)
                
                // API ÏöîÏ≤≠ Ï†úÌïúÏùÑ Í≥†Î†§Ìïú ÎîúÎ†àÏù¥
                if leagueId != SupportedLeagues.allLeagues.last {
                    try await Task.sleep(nanoseconds: 500_000_000) // 0.5Ï¥à ÎåÄÍ∏∞
                }
            } catch {
                print("‚ùå Error fetching league details for league \(leagueId): \(error.localizedDescription)")
                continue
            }
        }
        
        print("\nüìä Total leagues fetched: \(allLeagues.count)")
        return allLeagues
    }
    
    func getLeagueDetails(leagueId: Int, season: Int) async throws -> LeagueDetails {
        let endpoint = "/leagues?id=\(leagueId)&season=\(season)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching league details for league \(leagueId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "League Details")
        
        let decoder = JSONDecoder()
        let leaguesResponse = try decoder.decode(LeaguesResponse.self, from: data)
        
        if !leaguesResponse.errors.isEmpty {
            throw FootballAPIError.apiError(leaguesResponse.errors)
        }
        
        guard let leagueDetails = leaguesResponse.response.first else {
            throw FootballAPIError.apiError(["Î¶¨Í∑∏ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
        }
        
        return leagueDetails
    }
    
    // MARK: - Standings
    
    func getStandings(leagueId: Int, season: Int) async throws -> [Standing] {
        let endpoint = "/standings?league=\(leagueId)&season=\(season)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching standings for league \(leagueId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Standings")
        
        let decoder = JSONDecoder()
        let standingsResponse = try decoder.decode(StandingsResponse.self, from: data)
        
        if !standingsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(standingsResponse.errors)
        }
        
        guard let standings = standingsResponse.response.first?.league.standings.first else {
            throw FootballAPIError.apiError(["ÏàúÏúÑ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
        }
        
        return standings
    }
    
    // MARK: - Fixture Events
    
    func getFixtureEvents(fixtureId: Int, teamId: Int? = nil, playerId: Int? = nil) async throws -> [FixtureEvent] {
        var endpoint = "/fixtures/events?fixture=\(fixtureId)"
        if let teamId = teamId {
            endpoint += "&team=\(teamId)"
        }
        if let playerId = playerId {
            endpoint += "&player=\(playerId)"
        }
        
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching events for fixture \(fixtureId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Fixture Events")
        
        let decoder = JSONDecoder()
        let eventsResponse = try decoder.decode(FixtureEventResponse.self, from: data)
        
        if !eventsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(eventsResponse.errors)
        }
        
        return eventsResponse.response
    }
    
    // MARK: - Fixture Statistics
    
    func getFixtureStatistics(fixtureId: Int, teamId: Int? = nil, type: StatisticType? = nil, includeHalves: Bool = false) async throws -> [TeamStatistics] {
        var endpoint = "/fixtures/statistics?fixture=\(fixtureId)"
        if let teamId = teamId {
            endpoint += "&team=\(teamId)"
        }
        if let type = type {
            endpoint += "&type=\(type.rawValue.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? type.rawValue)"
        }
        if includeHalves {
            endpoint += "&half=true"
        }
        
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching statistics for fixture \(fixtureId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        print("\nüì¶ Raw Statistics Response:")
        if let jsonString = String(data: data, encoding: .utf8) {
            print(jsonString)
        }
        
        // ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÏûêÏÑ∏Ìûà Ï∂úÎ†•
        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let response = json["response"] as? [[String: Any]] {
            print("\nüìä Detailed Statistics:")
            for teamStats in response {
                if let team = teamStats["team"] as? [String: Any],
                   let teamName = team["name"] as? String,
                   let statistics = teamStats["statistics"] as? [[String: Any]] {
                    print("\nüèÉ‚Äç‚ôÇÔ∏è Team: \(teamName)")
                    for stat in statistics {
                        if let type = stat["type"] as? String,
                           let value = stat["value"] {
                            print("   ‚Ä¢ \(type): \(value)")
                        }
                    }
                }
            }
        }
        
        do {
            // Î®ºÏ†Ä JSON Íµ¨Ï°∞ Ï∂úÎ†•
            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                print("\nüì¶ JSON Structure:")
                print(json)
            }
            
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            
            do {
                let statisticsResponse = try decoder.decode(FixtureStatisticsResponse.self, from: data)
                
                if !statisticsResponse.errors.isEmpty {
                    throw FootballAPIError.apiError(statisticsResponse.errors)
                }
                
                print("\n‚úÖ Successfully decoded statistics response")
                print("üìä Teams found: \(statisticsResponse.response.count)")
                for team in statisticsResponse.response {
                    print("   - \(team.team.name): \(team.statistics.count) statistics")
                    for stat in team.statistics {
                        print("     ‚Ä¢ Type: '\(stat.type)'")
                    print("       Raw Type: '\(stat.type)'")
                    print("       Raw Value: '\(stat.value)'")
                    print("       Display Value: '\(stat.value.displayValue)'")
                    print("       Dictionary Key: '\(stat.type)'")
                    print("       All Stats Keys: '\(team.statistics.map { $0.type }.joined(separator: ", "))'")
                    }
                }
                
                return statisticsResponse.response
                
            } catch DecodingError.keyNotFound(let key, let context) {
                print("‚ùå Key '\(key)' not found:", context.debugDescription)
                print("Coding path:", context.codingPath)
                throw FootballAPIError.decodingError(DecodingError.keyNotFound(key, context))
            } catch DecodingError.typeMismatch(let type, let context) {
                print("‚ùå Type '\(type)' mismatch:", context.debugDescription)
                print("Coding path:", context.codingPath)
                throw FootballAPIError.decodingError(DecodingError.typeMismatch(type, context))
            } catch {
                print("‚ùå Other decoding error:", error)
                throw FootballAPIError.decodingError(error)
            }
            
        } catch {
            print("\n‚ùå Failed to decode statistics response: \(error)")
            throw FootballAPIError.decodingError(error)
        }
    }
    
    func getFixtureHalfStatistics(fixtureId: Int) async throws -> [HalfTeamStatistics] {
        let endpoint = "/fixtures/statistics?fixture=\(fixtureId)&half=true"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching half statistics for fixture \(fixtureId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        print("\nüì¶ Raw Half Statistics Response:")
        if let jsonString = String(data: data, encoding: .utf8) {
            print(jsonString)
        }
        
        // JSON Íµ¨Ï°∞ Ï∂úÎ†•
        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            print("\nüì¶ JSON Structure:")
            print(json)
        }
        
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        
        let statisticsResponse = try decoder.decode(HalfStatisticsResponse.self, from: data)
        
        if !statisticsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(statisticsResponse.errors)
        }
        
        print("\n‚úÖ Successfully decoded half statistics response")
        print("üìä Teams found: \(statisticsResponse.response.count)")
        for team in statisticsResponse.response {
            print("   - \(team.team.name):")
            let stats = team.halfStats
            print("     First Half: \(stats.firstHalf.count) statistics")
            for stat in stats.firstHalf {
                print("       ‚Ä¢ \(stat.type): \(stat.value.displayValue)")
            }
            print("     Second Half: \(stats.secondHalf.count) statistics")
            for stat in stats.secondHalf {
                print("       ‚Ä¢ \(stat.type): \(stat.value.displayValue)")
            }
        }
        
        return statisticsResponse.response
    }
    
    // MARK: - Fixture Players Statistics
    
    func getFixturePlayersStatistics(fixtureId: Int) async throws -> [TeamPlayersStatistics] {
        let endpoint = "/fixtures/players?fixture=\(fixtureId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching players statistics for fixture \(fixtureId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Fixture Players Statistics")
        
        let decoder = JSONDecoder()
        let playersResponse = try decoder.decode(FixturePlayersResponse.self, from: data)
        
        if !playersResponse.errors.isEmpty {
            throw FootballAPIError.apiError(playersResponse.errors)
        }
        
        return playersResponse.response
    }
    
    // MARK: - Player Statistics
    
    func getPlayerStatistics(playerId: Int, season: Int) async throws -> [PlayerProfileData] {
        let endpoint = "/players?id=\(playerId)&season=\(season)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching statistics for player \(playerId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Player Statistics")
        
        let decoder = JSONDecoder()
        let playerResponse = try decoder.decode(PlayerStatisticsResponse.self, from: data)
        
        if !playerResponse.errors.isEmpty {
            throw FootballAPIError.apiError(playerResponse.errors)
        }
        
        return playerResponse.response
    }
    
    // MARK: - Team Fixtures
    
    func getTeamFixtures(teamId: Int, season: Int, last: Int? = nil) async throws -> [Fixture] {
        var endpoint = "/fixtures?team=\(teamId)&season=\(season)"
        if let last = last {
            endpoint += "&last=\(last)"
        }
        
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching fixtures for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Fixtures")
        
        let decoder = JSONDecoder()
        let fixturesResponse = try decoder.decode(FixturesResponse.self, from: data)
        
        if !fixturesResponse.errors.isEmpty {
            throw FootballAPIError.apiError(fixturesResponse.errors)
        }
        
        return fixturesResponse.response.sorted { fixture1, fixture2 in
            fixture1.fixture.date > fixture2.fixture.date
        }
    }
    
    // MARK: - Fixtures
    
    func getFixtures(leagueIds: [Int], season: Int) async throws -> [Fixture] {
        var allFixtures: [Fixture] = []
        let decoder = JSONDecoder()
        let dateRange = getDateRange(forSeason: season)
        
        // Î¶¨Í∑∏ IDÎ•º ÏâºÌëúÎ°ú Íµ¨Î∂ÑÎêú Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
        let leaguesStr = leagueIds.map { String($0) }.joined(separator: ",")
        
        // 1. Ïã§ÏãúÍ∞Ñ Í≤ΩÍ∏∞ Í∞ÄÏ†∏Ïò§Í∏∞ (ÌòÑÏû¨ ÏãúÏ¶åÎßå)
        if season == 2024 {
            let liveEndpoint = "/fixtures?live=all&league=\(leaguesStr)&season=\(season)"
            let liveRequest = createRequest(liveEndpoint)
            
            print("\nüì° Fetching live fixtures for leagues \(leaguesStr)...")
            
            do {
                let (liveData, liveResponse) = try await URLSession.shared.data(for: liveRequest)
                try handleResponse(liveResponse)
                
                // API ÏùëÎãµ Î°úÍπÖ
                logResponse(data: liveData, endpoint: "Live Fixtures")
                
                let liveFixtures = try decoder.decode(FixturesResponse.self, from: liveData)
                if !liveFixtures.errors.isEmpty {
                    print("‚ö†Ô∏è Live fixtures API errors: \(liveFixtures.errors.joined(separator: ", "))")
                } else {
                    print("‚úÖ Found \(liveFixtures.response.count) live fixtures")
                    allFixtures.append(contentsOf: liveFixtures.response)
                }
            } catch {
                print("‚ö†Ô∏è Error fetching live fixtures: \(error.localizedDescription)")
                // ÎùºÏù¥Î∏å Í≤ΩÍ∏∞ Î°úÎìú Ïã§Ìå®Îäî Î¨¥ÏãúÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ
            }
            
            // API ÏöîÏ≤≠ Ï†úÌïúÏùÑ Í≥†Î†§Ìïú ÎîúÎ†àÏù¥
            do {
                try await Task.sleep(nanoseconds: 500_000_000) // 0.5Ï¥à ÎåÄÍ∏∞
            } catch {
                if error is CancellationError {
                    print("‚ö†Ô∏è Task cancelled during delay (normal)")
                } else {
                    print("‚ö†Ô∏è Task.sleep error: \(error.localizedDescription)")
                }
            }
        }
        
        // 2. ÎÇ†Ïßú Î≤îÏúÑÎ°ú Í≤ΩÍ∏∞ Í∞ÄÏ†∏Ïò§Í∏∞
        let fixturesEndpoint = "/fixtures?league=\(leaguesStr)&season=\(season)&from=\(dateRange.from)&to=\(dateRange.to)"
        let fixturesRequest = createRequest(fixturesEndpoint)
        
        print("\nüì° Fetching fixtures for leagues \(leaguesStr)...")
        print("üìÖ Date range: \(dateRange.from) to \(dateRange.to)")
        
        let (fixturesData, fixturesResponse) = try await URLSession.shared.data(for: fixturesRequest)
        try handleResponse(fixturesResponse)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: fixturesData, endpoint: "Fixtures")
        
        let fixtures = try decoder.decode(FixturesResponse.self, from: fixturesData)
        if !fixtures.errors.isEmpty {
            throw FootballAPIError.apiError(fixtures.errors)
        }
        
        print("‚úÖ Received \(fixtures.response.count) fixtures from API")
        allFixtures.append(contentsOf: fixtures.response)
        
        // Ï§ëÎ≥µ Ï†úÍ±∞
        let uniqueFixtures = Array(Set(allFixtures))
        
        print("\n‚úÖ Successfully fetched \(uniqueFixtures.count) unique fixtures for leagues \(leaguesStr)")
        return uniqueFixtures.sorted { fixture1, fixture2 in
            fixture1.fixture.date < fixture2.fixture.date
        }
    }
    
    // Îã®Ïùº Î¶¨Í∑∏ Î≤ÑÏ†Ñ (Ïù¥Ï†Ñ Î≤ÑÏ†ÑÍ≥ºÏùò Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    func getFixtures(leagueId: Int, season: Int) async throws -> [Fixture] {
        return try await getFixtures(leagueIds: [leagueId], season: season)
    }
    
    // MARK: - Head to Head
    
    func getHeadToHead(team1Id: Int, team2Id: Int, last: Int = 20) async throws -> [Fixture] {
        let endpoint = "/fixtures/headtohead?h2h=\(team1Id)-\(team2Id)&last=\(last)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching head to head statistics...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Head to Head")
        
        let decoder = JSONDecoder()
        let headToHeadResponse = try decoder.decode(HeadToHeadResponse.self, from: data)
        
        if !headToHeadResponse.errors.isEmpty {
            throw FootballAPIError.apiError(headToHeadResponse.errors)
        }
        
        return headToHeadResponse.response
    }
    
    // MARK: - Lineups
    
    func getFixtureLineups(fixtureId: Int, teamId: Int? = nil) async throws -> [TeamLineup] {
        var endpoint = "/fixtures/lineups?fixture=\(fixtureId)"
        if let teamId = teamId {
            endpoint += "&team=\(teamId)"
        }
        
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching lineups for fixture \(fixtureId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Fixture Lineups")
        
        let decoder = JSONDecoder()
        let lineupsResponse = try decoder.decode(FixtureLineupResponse.self, from: data)
        
        if !lineupsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(lineupsResponse.errors)
        }
        
        return lineupsResponse.response
    }
    
    // MARK: - Team Profile
    
    func getTeamProfile(teamId: Int) async throws -> TeamProfile {
        let endpoint = "/teams?id=\(teamId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching team profile for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Profile")
        
        let decoder = JSONDecoder()
        let profileResponse = try decoder.decode(TeamProfileResponse.self, from: data)
        
        if !profileResponse.errors.isEmpty {
            throw FootballAPIError.apiError(profileResponse.errors)
        }
        
        guard let profile = profileResponse.response.first else {
            throw FootballAPIError.apiError(["ÌåÄ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
        }
        
        return profile
    }
    
    // MARK: - Team Statistics and Standing
    func getTeamStatistics(teamId: Int, leagueId: Int, season: Int) async throws -> TeamSeasonStatistics {
        let endpoint = "/teams/statistics?team=\(teamId)&league=\(leagueId)&season=\(season)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching team statistics for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Statistics")
        
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let statsResponse = try decoder.decode(TeamStatisticsResponse.self, from: data)
        
        if !statsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(statsResponse.errors)
        }
        
        return statsResponse.response
    }
    
    func getTeamStanding(teamId: Int, leagueId: Int, season: Int) async throws -> TeamStanding? {
        let endpoint = "/standings?team=\(teamId)&league=\(leagueId)&season=\(season)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching team standing for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Standing")
        
        let decoder = JSONDecoder()
        let standingResponse = try decoder.decode(TeamStandingResponse.self, from: data)
        
        if !standingResponse.errors.isEmpty {
            throw FootballAPIError.apiError(standingResponse.errors)
        }
        
        return standingResponse.response.first?.league.standings.first?.first
    }
    
    // MARK: - Player Profile
    
    func getPlayerProfile(playerId: Int) async throws -> PlayerProfileData {
        // 1. Î®ºÏ†Ä players/profiles ÏóîÎìúÌè¨Ïù∏Ìä∏Î°ú ÏµúÏã† ÏÑ†Ïàò Ï†ïÎ≥¥ ÏãúÎèÑ
        do {
            let profileData = try await getPlayerProfileFromProfiles(playerId: playerId)
            print("‚úÖ Successfully loaded player profile from profiles endpoint")
            return profileData
        } catch {
            print("‚ö†Ô∏è Failed to load player profile from profiles endpoint: \(error.localizedDescription)")
            print("‚ö†Ô∏è Falling back to season-based endpoint...")
            // Ïã§Ìå®ÌïòÎ©¥ Í∏∞Ï°¥ ÏãúÏ¶å Í∏∞Î∞ò Î©îÏÑúÎìúÎ°ú Ìè¥Î∞±
            return try await getPlayerProfileFromSeasons(playerId: playerId)
        }
    }
    
    // Í∏∞Ï°¥ ÏãúÏ¶å Í∏∞Î∞ò Î©îÏÑúÎìú (Ïù¥Î¶Ñ Î≥ÄÍ≤Ω)
    private func getPlayerProfileFromSeasons(playerId: Int) async throws -> PlayerProfileData {
        // ÏãúÎèÑÌï† ÏãúÏ¶å Î™©Î°ù (ÏµúÏã† ÏãúÏ¶åÎ∂ÄÌÑ∞)
        let seasons = [2024, 2023, 2022]
        var lastError: Error? = nil
        
        // Í∞Å ÏãúÏ¶åÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏãúÎèÑ
        for season in seasons {
            do {
                let endpoint = "/players?id=\(playerId)&season=\(season)"
                let request = createRequest(endpoint)
                
                print("\nüì° Fetching profile for player \(playerId) (season \(season))...")
                let (data, response) = try await URLSession.shared.data(for: request)
                try handleResponse(response)
                
                // API ÏùëÎãµ Î°úÍπÖ
                logResponse(data: data, endpoint: "Player Profile (Season \(season))")
                
                // JSON Íµ¨Ï°∞ Î∂ÑÏÑù (ÎîîÎ≤ÑÍπÖÏö©)
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    print("\nüìä Player Profile JSON Structure:")
                    if let results = json["results"] as? Int {
                        print("Results: \(results)")
                    }
                    if let response = json["response"] as? [[String: Any]], !response.isEmpty {
                        print("Response items: \(response.count)")
                        if let firstPlayer = response.first {
                            print("Player keys: \(firstPlayer.keys.joined(separator: ", "))")
                            if let player = firstPlayer["player"] as? [String: Any] {
                                print("Player info keys: \(player.keys.joined(separator: ", "))")
                            }
                            if let statistics = firstPlayer["statistics"] as? [[String: Any]] {
                                print("Statistics items: \(statistics.count)")
                            }
                        }
                    }
                }
                
                let decoder = JSONDecoder()
                
                // ÎîîÏΩîÎî© ÏãúÎèÑ
                do {
                    let profileResponse = try decoder.decode(PlayerProfileResponse.self, from: data)
                    
                    if !profileResponse.errors.isEmpty {
                        print("‚ö†Ô∏è API errors: \(profileResponse.errors.joined(separator: ", "))")
                        continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                    }
                    
                    guard profileResponse.results > 0,
                          let profile = profileResponse.response.first else {
                        print("‚ö†Ô∏è No player data found for season \(season)")
                        continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                    }
                    
                    print("‚úÖ Successfully loaded player profile for season \(season)")
                    return profile
                    
                } catch DecodingError.keyNotFound(let key, let context) {
                    print("‚ùå Decoding error - Key '\(key)' not found: \(context.debugDescription)")
                    print("Coding path: \(context.codingPath)")
                    lastError = DecodingError.keyNotFound(key, context)
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                } catch DecodingError.typeMismatch(let type, let context) {
                    print("‚ùå Decoding error - Type '\(type)' mismatch: \(context.debugDescription)")
                    print("Coding path: \(context.codingPath)")
                    lastError = DecodingError.typeMismatch(type, context)
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                } catch {
                    print("‚ùå Other decoding error: \(error)")
                    lastError = error
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                }
            } catch {
                print("‚ùå API request error for season \(season): \(error)")
                lastError = error
                continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
            }
        }
        
        // Î™®Îì† ÏãúÏ¶åÏóêÏÑú Ïã§Ìå®Ìïú Í≤ΩÏö∞
        if let error = lastError {
            throw FootballAPIError.decodingError(error)
        } else {
            throw FootballAPIError.apiError(["ÏÑ†Ïàò Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
        }
    }
    
    // ÏÉàÎ°úÏö¥ profiles ÏóîÎìúÌè¨Ïù∏Ìä∏ Î©îÏÑúÎìú
    private func getPlayerProfileFromProfiles(playerId: Int) async throws -> PlayerProfileData {
        let endpoint = "/players/profiles?id=\(playerId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching profile for player \(playerId) from profiles endpoint...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Player Profiles")
        
        // JSON Íµ¨Ï°∞ Î∂ÑÏÑù (ÎîîÎ≤ÑÍπÖÏö©)
        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            print("\nüìä Player Profiles JSON Structure:")
            if let results = json["results"] as? Int {
                print("Results: \(results)")
            }
            if let response = json["response"] as? [[String: Any]], !response.isEmpty {
                print("Response items: \(response.count)")
                if let firstPlayer = response.first {
                    print("Player keys: \(firstPlayer.keys.joined(separator: ", "))")
                }
            }
        }
        
        let decoder = JSONDecoder()
        
        // ÎîîÏΩîÎî© ÏãúÎèÑ
        do {
            // ÏùëÎãµ Íµ¨Ï°∞Í∞Ä Îã§Î•º Ïàò ÏûàÏúºÎØÄÎ°ú Î®ºÏ†Ä ÏùºÎ∞ò Íµ¨Ï°∞Î°ú ÎîîÏΩîÎî©
            let profileResponse = try decoder.decode(PlayerProfileResponse.self, from: data)
            
            if !profileResponse.errors.isEmpty {
                throw FootballAPIError.apiError(profileResponse.errors)
            }
            
            guard profileResponse.results > 0,
                  let profile = profileResponse.response.first else {
                throw FootballAPIError.apiError(["ÏÑ†Ïàò Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
            }
            
            return profile
            
        } catch DecodingError.keyNotFound(let key, let context) {
            print("‚ùå Profiles decoding error - Key '\(key)' not found: \(context.debugDescription)")
            print("Coding path: \(context.codingPath)")
            throw FootballAPIError.decodingError(DecodingError.keyNotFound(key, context))
        } catch DecodingError.typeMismatch(let type, let context) {
            print("‚ùå Profiles decoding error - Type '\(type)' mismatch: \(context.debugDescription)")
            print("Coding path: \(context.codingPath)")
            throw FootballAPIError.decodingError(DecodingError.typeMismatch(type, context))
        } catch {
            print("‚ùå Other profiles decoding error: \(error)")
            throw FootballAPIError.decodingError(error)
        }
    }
    
    func getPlayerCareerStats(playerId: Int) async throws -> [PlayerCareerStats] {
        let endpoint = "/players/teams?player=\(playerId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching career stats for player \(playerId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Player Career")
        
        // JSON Íµ¨Ï°∞ Î∂ÑÏÑù (ÎîîÎ≤ÑÍπÖÏö©)
        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            print("\nüìä Player Career JSON Structure:")
            if let results = json["results"] as? Int {
                print("Results: \(results)")
            }
            if let response = json["response"] as? [[String: Any]], !response.isEmpty {
                print("Response items: \(response.count)")
                if let firstTeam = response.first {
                    print("Team keys: \(firstTeam.keys.joined(separator: ", "))")
                }
            }
        }
        
        let decoder = JSONDecoder()
        
        do {
            let careerResponse = try decoder.decode(PlayerCareerResponse.self, from: data)
            
            if !careerResponse.errors.isEmpty {
                print("‚ö†Ô∏è API errors: \(careerResponse.errors.joined(separator: ", "))")
                return [] // ÏóêÎü¨Í∞Ä ÏûàÏßÄÎßå Îπà Î∞∞Ïó¥ Î∞òÌôòÌïòÏó¨ Ïï±Ïù¥ Í≥ÑÏÜç ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
            }
            
            guard careerResponse.results > 0,
                  !careerResponse.response.isEmpty else {
                print("‚ö†Ô∏è No career data found for player \(playerId)")
                return [] // Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏßÄÎßå Îπà Î∞∞Ïó¥ Î∞òÌôòÌïòÏó¨ Ïï±Ïù¥ Í≥ÑÏÜç ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
            }
            
            // CareerTeamResponseÎ•º PlayerCareerStatsÎ°ú Î≥ÄÌôò
            return careerResponse.response.map { teamResponse in
                PlayerCareerStats(
                    team: teamResponse.team,
                    seasons: teamResponse.seasons
                )
            }
            
        } catch DecodingError.keyNotFound(let key, let context) {
            print("‚ùå Career decoding error - Key '\(key)' not found: \(context.debugDescription)")
            print("Coding path: \(context.codingPath)")
            return [] // ÎîîÏΩîÎî© ÏóêÎü¨Í∞Ä ÏûàÏßÄÎßå Îπà Î∞∞Ïó¥ Î∞òÌôòÌïòÏó¨ Ïï±Ïù¥ Í≥ÑÏÜç ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
        } catch DecodingError.typeMismatch(let type, let context) {
            print("‚ùå Career decoding error - Type '\(type)' mismatch: \(context.debugDescription)")
            print("Coding path: \(context.codingPath)")
            return [] // ÎîîÏΩîÎî© ÏóêÎü¨Í∞Ä ÏûàÏßÄÎßå Îπà Î∞∞Ïó¥ Î∞òÌôòÌïòÏó¨ Ïï±Ïù¥ Í≥ÑÏÜç ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
        } catch {
            print("‚ùå Other career decoding error: \(error)")
            throw FootballAPIError.decodingError(error)
        }
    }
    
    func getPlayerSeasonalStats(playerId: Int, season: Int) async throws -> [PlayerSeasonStats] {
        // ÏãúÎèÑÌï† ÏãúÏ¶å Î™©Î°ù (ÏßÄÏ†ïÎêú ÏãúÏ¶åÍ≥º Ïù¥Ï†Ñ ÏãúÏ¶åÎì§)
        let seasons = [season, season-1, season-2].filter { $0 > 0 }
        var lastError: Error? = nil
        
        // Í∞Å ÏãúÏ¶åÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏãúÎèÑ
        for trySeason in seasons {
            do {
                let endpoint = "/players?id=\(playerId)&season=\(trySeason)"
                let request = createRequest(endpoint)
                
                print("\nüì° Fetching seasonal stats for player \(playerId) (season \(trySeason))...")
                let (data, response) = try await URLSession.shared.data(for: request)
                try handleResponse(response)
                
                // API ÏùëÎãµ Î°úÍπÖ
                logResponse(data: data, endpoint: "Player Seasonal Stats (Season \(trySeason))")
                
                // JSON Íµ¨Ï°∞ Î∂ÑÏÑù (ÎîîÎ≤ÑÍπÖÏö©)
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    print("\nüìä Player Seasonal Stats JSON Structure:")
                    if let results = json["results"] as? Int {
                        print("Results: \(results)")
                    }
                }
                
                let decoder = JSONDecoder()
                
                do {
                    let statsResponse = try decoder.decode(PlayerSeasonalStatsResponse.self, from: data)
                    
                    if !statsResponse.errors.isEmpty {
                        print("‚ö†Ô∏è API errors: \(statsResponse.errors.joined(separator: ", "))")
                        continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                    }
                    
                    guard statsResponse.results > 0,
                          !statsResponse.response.isEmpty else {
                        print("‚ö†Ô∏è No seasonal stats found for player \(playerId) in season \(trySeason)")
                        continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                    }
                    
                    print("‚úÖ Successfully loaded seasonal stats for player \(playerId) in season \(trySeason)")
                    return statsResponse.response
                    
                } catch DecodingError.keyNotFound(let key, let context) {
                    print("‚ùå Seasonal stats decoding error - Key '\(key)' not found: \(context.debugDescription)")
                    print("Coding path: \(context.codingPath)")
                    lastError = DecodingError.keyNotFound(key, context)
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                } catch DecodingError.typeMismatch(let type, let context) {
                    print("‚ùå Seasonal stats decoding error - Type '\(type)' mismatch: \(context.debugDescription)")
                    print("Coding path: \(context.codingPath)")
                    lastError = DecodingError.typeMismatch(type, context)
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                } catch {
                    print("‚ùå Other seasonal stats decoding error: \(error)")
                    lastError = error
                    continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
                }
            } catch {
                print("‚ùå API request error for season \(trySeason): \(error)")
                lastError = error
                continue // Îã§Ïùå ÏãúÏ¶å ÏãúÎèÑ
            }
        }
        
        // Î™®Îì† ÏãúÏ¶åÏóêÏÑú Ïã§Ìå®Ìïú Í≤ΩÏö∞
        if let error = lastError {
            throw FootballAPIError.decodingError(error)
        } else {
            throw FootballAPIError.apiError(["ÏÑ†Ïàò ÏãúÏ¶å ÌÜµÍ≥ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."])
        }
    }
    
    // MARK: - Team Squad
    func getTeamSquad(teamId: Int) async throws -> [PlayerResponse] {
        let endpoint = "/players/squads?team=\(teamId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching squad for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Squad")
        
        let decoder = JSONDecoder()
        do {
            let squadResponse = try decoder.decode(SquadResponse.self, from: data)
            
            if !squadResponse.errors.isEmpty {
                throw FootballAPIError.apiError(squadResponse.errors)
            }
            
            // ÏùëÎãµÏù¥ ÎπÑÏñ¥ÏûàÎäî Í≤ΩÏö∞
            if squadResponse.response.isEmpty {
                return []
            }
            
            // TeamSquadResponseÎ•º PlayerResponse Î∞∞Ïó¥Î°ú Î≥ÄÌôò
            return squadResponse.response.first?.toPlayerResponses() ?? []
            
        } catch DecodingError.keyNotFound(let key, let context) {
            print("‚ùå Squad decoding error - Key '\(key)' not found:", context.debugDescription)
            // ÎîîÏΩîÎî© ÏóêÎü¨ Î∞úÏÉù Ïãú Îπà Î∞∞Ïó¥ Î∞òÌôò
            return []
        } catch {
            print("‚ùå Squad decoding error:", error)
            throw FootballAPIError.decodingError(error)
        }
    }
    
    func getTeamSeasons(teamId: Int) async throws -> [Int] {
        let endpoint = "/teams/seasons?team=\(teamId)"
        let request = createRequest(endpoint)
        
        print("\nüì° Fetching seasons for team \(teamId)...")
        let (data, response) = try await URLSession.shared.data(for: request)
        try handleResponse(response)
        
        // API ÏùëÎãµ Î°úÍπÖ
        logResponse(data: data, endpoint: "Team Seasons")
        
        struct SeasonsResponse: Codable {
            let response: [Int]
            let errors: [String]
        }
        
        let decoder = JSONDecoder()
        let seasonsResponse = try decoder.decode(SeasonsResponse.self, from: data)
        
        if !seasonsResponse.errors.isEmpty {
            throw FootballAPIError.apiError(seasonsResponse.errors)
        }
        
        return seasonsResponse.response.sorted(by: >)
    }
    
    // MARK: - Private Methods
    
    private init() {
        // Info.plistÏóêÏÑú API ÌÇ§ ÏùΩÍ∏∞
        guard let apiKey = Bundle.main.object(forInfoDictionaryKey: "FootballAPIKey") as? String else {
            fatalError("FootballAPIKey not found in Info.plist")
        }
        self.apiKey = apiKey
    }
    
    func createRequest(_ endpoint: String) -> URLRequest {
        guard let url = URL(string: baseURL + endpoint) else {
            fatalError("Invalid URL: \(baseURL + endpoint)")
        }
        
        var request = URLRequest(url: url,
                                cachePolicy: .reloadIgnoringLocalCacheData, // Ï∫êÏãú Î¨¥ÏãúÌïòÍ≥† Ìï≠ÏÉÅ ÏÉàÎ°ú Î°úÎìú
                                timeoutInterval: 20.0) // ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
        
        request.addValue(apiKey, forHTTPHeaderField: "x-rapidapi-key")
        request.addValue(host, forHTTPHeaderField: "x-rapidapi-host")
        request.httpMethod = "GET"
        
        print("üåê Request URL: \(url.absoluteString)")
        print("üìã Request Headers:")
        request.allHTTPHeaderFields?.forEach { key, value in
            let maskedValue = key.lowercased() == "x-rapidapi-key" ? "****" : value
            print("  \(key): \(maskedValue)")
        }
        
        return request
    }
    
    private func logResponse(data: Data, endpoint: String) {
        if let jsonObject = try? JSONSerialization.jsonObject(with: data),
           let prettyData = try? JSONSerialization.data(withJSONObject: jsonObject, options: .prettyPrinted),
           let prettyString = String(data: prettyData, encoding: .utf8) {
            print("\nüì¶ \(endpoint) Response:")
            print(prettyString)
        }
    }
    
    private func updateRateLimits(_ response: HTTPURLResponse) {
        // ÏùºÏùº ÏöîÏ≤≠ Ï†úÌïú
        if let limit = response.value(forHTTPHeaderField: "x-ratelimit-requests-limit"),
           let remaining = response.value(forHTTPHeaderField: "x-ratelimit-requests-remaining") {
            requestsLimit = Int(limit) ?? 0
            requestsRemaining = Int(remaining) ?? 0
        }
        
        // Î∂ÑÎãπ ÏöîÏ≤≠ Ï†úÌïú
        if let perMinuteLimit = response.value(forHTTPHeaderField: "X-RateLimit-Limit"),
           let perMinuteRemaining = response.value(forHTTPHeaderField: "X-RateLimit-Remaining") {
            rateLimitPerMinute = Int(perMinuteLimit) ?? 0
            rateLimitRemainingPerMinute = Int(perMinuteRemaining) ?? 0
        }
        
        print("\nüìä API Requests:")
        print("  Daily - Limit: \(requestsLimit), Remaining: \(requestsRemaining)")
        print("  Per Minute - Limit: \(rateLimitPerMinute), Remaining: \(rateLimitRemainingPerMinute)")
    }
    
    func handleResponse(_ response: URLResponse?) throws {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw FootballAPIError.invalidResponse
        }
        
        print("\nüì• Response Status Code: \(httpResponse.statusCode)")
        updateRateLimits(httpResponse)
        
        guard (200...299).contains(httpResponse.statusCode) else {
            throw FootballAPIError.apiError(["ÏÑúÎ≤Ñ Ïò§Î•ò: HTTP \(httpResponse.statusCode)"])
        }
        
        // ÏöîÏ≤≠ Ï†úÌïú ÌôïÏù∏
        if requestsRemaining <= 0 {
            throw FootballAPIError.rateLimitExceeded
        }
    }
    
    private func getDateRange(forSeason season: Int) -> (from: String, to: String) {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        dateFormatter.timeZone = TimeZone(identifier: "UTC")
        
        let currentSeason = 2024
        let calendar = Calendar.current
        
        // ÌòÑÏû¨ ÎÇ†ÏßúÎ•º Í∏∞Ï§ÄÏúºÎ°ú ÏÇ¨Ïö©
        let referenceDate = Date()
        
        if season == currentSeason {
            // ÌòÑÏû¨ ÏãúÏ¶åÏù∏ Í≤ΩÏö∞ ÏãúÏ¶å ÏãúÏûëÏùºÎ∂ÄÌÑ∞ Í∏∞Ï§Ä ÎÇ†Ïßú Í∏∞Ï§Ä Ï†ÑÌõÑ 15Ïùº Î≤îÏúÑ
            let from = "2024-08-01" // ÏãúÏ¶å ÏãúÏûëÏùº
            
            // Í∏∞Ï§Ä ÎÇ†Ïßú Í∏∞Ï§Ä 15Ïùº Ï†Ñ
            let fromDate = calendar.date(byAdding: .day, value: -15, to: referenceDate) ?? referenceDate
            let toDate = calendar.date(byAdding: .day, value: 15, to: referenceDate) ?? referenceDate
            
            let actualFrom = max(fromDate, dateFormatter.date(from: from) ?? fromDate)
            let actualFromStr = dateFormatter.string(from: actualFrom)
            let toStr = dateFormatter.string(from: toDate)
            
            print("üìÖ Current season date range: \(actualFromStr) ~ \(toStr)")
            return (actualFromStr, toStr)
        } else {
            // Í≥ºÍ±∞ ÏãúÏ¶åÏù∏ Í≤ΩÏö∞ Ìï¥Îãπ ÏãúÏ¶åÏùò Ï†ÑÏ≤¥ Í∏∞Í∞Ñ
            let fromStr = "\(season)-07-01" // ÏãúÏ¶å ÏãúÏûë
            let toStr = "\(season + 1)-06-30" // ÏãúÏ¶å Ï¢ÖÎ£å
            
            print("üìÖ Past season date range: \(fromStr) ~ \(toStr)")
            return (fromStr, toStr)
        }
    }
}
